
To refer me : Nandi, S. (2023) ‘An Open Source Model to Simulate Wait Lists for Hospital Beds for NHS’. Southampton: University of Southampton.

#Official_NHS_SYSTEM_DYNAMIC_MODEL
access the text file named this for the final code 



# waiting_in_aNe
blueprint for an open-source model for NHS patients needing admission vs. not.
blueprint for an open-source model for NHS patients needing admission vs. not needing admission. Please note, that the number of beds being calculated and accounted for is not calculated in the new code, will add it by Wednesday (13th) The second part of the model deals with input from patients needing admission as an inflow
26/09/2023
Reproduced all the results as per the Stella model
Things to remember: seed values are added as random; seed(10) to be removed for various simulations and comparisons of all the varying results. It has only been added for reproducibility. 
Delay, RAMP and Smoothing to be replaced with the algorithm best suited for the NHS 

Divided into classes for ease of access and scalability


USER MANUAL

The Python 3 model simulates patient attendance and admission flows through the
accident and emergency departments of a hospital using the system dynamics simulation
technique. It models the interdependent modules (stocks and flows) to forecast
the emergency department’s projected admissions, waiting times, bed occupancy, and
discharges. The primary results generated by the model are:
• Net ED attendances
• Admission-to-attendance ratio
• Forecast non-elective length of stay
• Simulating results for the wait times for patients in the ED
• Simulating results for non-elective admissions
• Simulation Bed occupancy
• Visualization of these trends over time

A.1 Prerequisite
System prerequisites: Python is well supported by various operating systems. Python
has extensive support for Windows, Linux, and macOS.
For Windows users: Windows 7 and above are necessary
For Linux users: python 3 is supported in a wide range of Linux OS, including but not limited to
limited to Ubuntu, CentOS, Debian, etc.
For mac-OS users: Catalina, BigSur, and Monterey are popular versions where Python
3 is well supported.

While Python3 does come pre-installed for most Operating systems, one can also access
it from: https://www.python.org/downloads/
To run Python 3, two essential components are required: A Python interpreter which
can be downloaded from the above website or installed using a package manager like
Pip and Conda
Secondly, an IDE or code editor is required. One can use a simple code editor like
Notepad or more sophisticated IDEs like Visual Studio Code, Spyder, Jupyter, or IDLE
However, another very simple and dynamic IDE that is available to use is Google Colaboratory.
which is a free platform for data analysis and machine learning research,
it allows the execution of Python in a Jupyter Notebook environment, with access to
powerful Google features and resources. Almost all IDEs in use are cloud-integrated.
therefore one can save their work seamlessly and maintain pipelines of any changes
done on the system.
To run the model successfully, Python 3 is required. A version of Python 3.6 or
later would be most beneficial and accurate to run this model. The packages required
are:
• Pandas
• NumPy
• Matplotlib
• SciPy
• Seaborn

A.2 Functionalities in Python:
The model utilizes basic Python programming concepts to drive the simulation.
A.2.1 Recursion
A technique where a function calls itself to solve the problem. This function has two
elements, base cases that provide the termination conditions and recursive cases that
call the function to perform the calculation with new inputs. The process where the
function calls itself until the conditions are met is called the recursive technique.
It has been used in a couple of places where the method calls itself: In the class
RollingAverageEDAttendance the method- rolling average ed attendance avg Emg attendances()
calls itself to calculate the rolling average attendance from the historical attendance
taken. The class RollingAverageLossNonElective, outdated data(), uses recursion to
implement a delay queue. This provides a simple and efficient implementation to accumulate
or delay values over time.

A.2.2 Data Structures
The main data structures used are:
• Panda.Dataframe: A fundamental data structure used in data manipulation and
data analysis. It allows almost every datatype to be taken as inputs and can be
manipulated like a SQL table or spreadsheet. This stores and analyses the input
and output datasets, and the simulations are iterated within the Dataframes to
reflect the time series forecasts as well as store historical values.
• numpy.array: It is used to store numerical data like attendance
• deque: It is used to implement delay queues. RollingAverageLosNonElective
uses it efficiently to implement the delay functionality. The deque initially holds
the rolling average period LOS non-elective items. Each time a new LOS is delayed, it
is appended to the deque. When needed to be retrieved, the oldest value is returned
using the return function. Due to the fixed length, older values are shifted
out as values are ‘inserted’ in. While this is not an exact way to calculate the
delay within the system, deque provides an efficient and clean way to implement
the rolling buffer needed for the LOS forecast.
Further information can be found here : (https://docs.python.org/3/tutorial/datastructures.html)

A.2.3 OOP functionalities demonstrated
• Encapsulation
Each of the key model components is encapsulated in its own class.
RollingAvergaeEDattendance: encapsulates the functions and parameters like attendance
forecasting logic to calculate a module like that for rollingaverageedattendance_Emg attendance()
Similarly, Rolling Average Admission To Attendance Ratio, RollingAverageLosNon-
Elective and the dynamic model exercise encapsulation.
• Inheritance The model classes directly inherit from the base object class using
constructors like intr() and str()
• Polymorphism is practised by most classes, where each has used the same method
names to mimic or demonstrate particular functionalities.
• Composition: The DynamicModel class composes the classes as parameters and
fields to be used within the system dynamics model.
Further information can be found here : https://docs.python.org/3/tutorial/classes.html:

A.2.4 Running The Model:
To run the simulation:
• Download the code in your user directory with the.py extension.
• Update the input data file paths within the main section of the code
• Adjust simulation parameters as necessary in the main section of the code.
• Run all the sections of the Python system dynamics model. (For ease of understanding,
Google Colab allows segmentation of the model and one could run it
one by one to understand the workings of each.
The model is made to execute the simulation and save the results. CSV files for data
validation as well as testing.

A.2.5 Understanding the parameters involved
The main parameters that are configured within the model are :
• Simulation timeframes: start time sim, end date sim, and baseline dates are customisable
and calculated inputs that define the timeframe and timesteps of the
model
• Growth Assumptions: Population growth rates are considered for the calculation
of the emergency department’s total project attendance, other assumptions and
variables can be included within the model
• Resources: For this model, the main resource was the number of beds in each
additional week.
• Care process changes: Decreases in admission rates are monitored over time
and the time it took to reach that reduction.
These among others are completely customisable and can be moulded as per requirement.
As explained above, there are 4 main components which are divided into 4
classes, Rolling Average Admission To Attendance Ratio, RollingAverageLosNonElective,
RollingAverageEDattendance, and Dynamic Class along with the main parameters
of the program which can be altered as necessary. The model tries to be as accurate as
possible however fails to demonstrate key functionalities like Delay, Ramp and Smoothing
exactly like Stella as it is hard to understand and grasp the full functionality
of these mathematical calculations taking place in the Stella model.
Ramp: Ramping of the values up or down is handled within the Dynamic class, it takes
three main variables, slope, start time and end time for the calculation and linearly
ramps the values from 0 to the full scope over the specified timeframe.
Smoothing: Smoothing is used while calculating rolling averages of historical data, like
rollingAverageEDattendance and stock accumulation by modelling smooth accumulation
of stocks over time, by gradually increasing the inflows.
Delay: As described above uses deque to calculate the delay.
While these functionalities do not give the exact values produced by Stella Architect,
they form a basis of the simulation as they mimic the behaviour of real-life emergency
departments rather accurately. To better the model, customizing the input variables
and the calculations of these functions need to be standardised to be used across any
future model

The working principle for the Python model is quite intuitive and leaves room for scalability
wherever necessary.
